import { StimulusUse } from '../stimulus_use';
import { composeEventName, extendedEvent, method } from '../support/index';
const defaultOptions = {
    dispatchEvent: true,
    eventPrefix: true,
};
export class UseVisibility extends StimulusUse {
    constructor(controller, options = {}) {
        super(controller, options);
        this.observe = () => {
            this.controller.isVisible = !document.hidden;
            document.addEventListener('visibilitychange', this.handleVisibilityChange);
        };
        this.unobserve = () => {
            document.removeEventListener('visibilitychange', this.handleVisibilityChange);
        };
        // private
        this.becomesInvisible = (event) => {
            const eventName = composeEventName('invisible', this.controller, this.eventPrefix);
            this.controller.isVisible = false;
            method(this.controller, 'invisible').call(this.controller);
            this.log('invisible', { isVisible: false });
            this.dispatch(eventName, event);
        };
        this.becomesVisible = (event) => {
            const eventName = composeEventName('visible', this.controller, this.eventPrefix);
            this.controller.isVisible = true;
            method(this.controller, 'visible').call(this.controller);
            this.log('visible', { isVisible: true });
            this.dispatch(eventName, event);
        };
        this.dispatch = (eventName, event) => {
            if (this.dispatchEvent) {
                const detail = { controller: this.controller, isVisible: this.controller.isVisible };
                const visibilityEvent = extendedEvent(eventName, event || null, detail);
                this.controller.element.dispatchEvent(visibilityEvent);
                this.log('dispatchEvent', Object.assign({ eventName }, detail));
            }
        };
        this.handleVisibilityChange = (event) => {
            if (document.hidden) {
                this.becomesInvisible(event);
            }
            else {
                this.becomesVisible(event);
            }
        };
        const { dispatchEvent, eventPrefix } = Object.assign({}, defaultOptions, options);
        Object.assign(this, { dispatchEvent, eventPrefix });
        this.controller = controller;
        const disconnect = () => {
            this.unobserve();
            this.controllerDisconnect();
        };
        Object.assign(controller, { disconnect });
        // triggers initial callback on connect
        this.handleVisibilityChange();
        this.observe();
    }
}
export const useVisibility = (controller, options = {}) => {
    const observer = new UseVisibility(controller, options);
    return [observer.observe, observer.unobserve];
};
//# sourceMappingURL=use-visibility.js.map
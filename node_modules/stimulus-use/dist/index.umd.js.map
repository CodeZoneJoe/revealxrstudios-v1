{"version":3,"file":"index.umd.js","sources":["../src/support/index.ts","../src/use-intersection/use-intersection.ts","../src/use-intersection/intersection-controller.ts","../src/use-lazy-load/useLazyLoad.ts","../src/use-lazy-load/lazy-load-controller.ts","../src/use-resize/use-resize.ts","../src/use-resize/resize-controller.ts","../src/use-click-outside/use-click-outside.ts","../src/use-click-outside/click-outside-controller.ts","../src/stimulus_use.ts","../src/use-dispatch/use-dispatch.ts","../src/use-application/use-application.ts","../src/use-application/application-controller.ts","../src/use-idle/use-idle.ts","../src/use-idle/idle-controller.ts","../src/use-visibility/use-visibility.ts","../src/use-visibility/visibility-controller.ts","../src/use-hover/use-hover.ts","../src/use-hover/hover-controller.ts","../src/use-mutation/use-mutation.ts","../src/use-mutation/mutation-controller.ts","../src/use-target-mutation/use-target-mutation.ts","../src/use-target-mutation/target-mutation-controller.ts","../src/use-window-resize/use-window-resize.ts","../src/use-window-resize/window-resize-controller.ts","../src/use-debounce/use-debounce.ts","../src/use-throttle/use-throttle.ts","../src/use-meta/use-meta.ts","../src/use-transition/use-transition.ts","../src/use-transition/transition-controller.ts","../src/use-memo/use-memo.ts"],"sourcesContent":["import { Controller } from 'stimulus'\n\nexport const method = (controller: Controller, methodName: string): Function => {\n  const method = (controller as any)[methodName]\n  if (typeof method == 'function') {\n    return method\n  } else {\n    return (...args: any[]) => {}\n  }\n}\n\nexport const composeEventName = (name: string, controller: Controller, eventPrefix: boolean | string) => {\n  let composedName = name\n  if (eventPrefix === true) {\n    composedName = `${controller.identifier}:${name}`\n  } else if (typeof eventPrefix === 'string') {\n    composedName = `${eventPrefix}:${name}`\n  }\n  return composedName\n}\n\nexport const extendedEvent = (type: string, event: Event | null, detail: object): CustomEvent => {\n  const { bubbles, cancelable, composed } = event || { bubbles: true, cancelable: true, composed: true }\n\n  if (event) {\n    Object.assign(detail, { originalEvent: event })\n  }\n\n  const customEvent = new CustomEvent(type, {\n    bubbles,\n    cancelable,\n    composed,\n    detail,\n  })\n  return customEvent\n}\n\nexport function isElementInViewport(el: Element) {\n  const rect = el.getBoundingClientRect()\n\n  const windowHeight = (window.innerHeight || document.documentElement.clientHeight)\n  const windowWidth = (window.innerWidth || document.documentElement.clientWidth)\n\n  const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) >= 0)\n  const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) >= 0)\n\n  return (vertInView && horInView)\n}\n\n","import { IntersectionComposableController } from './intersection-controller'\nimport { method, extendedEvent, composeEventName } from '../support/index'\n\nexport interface IntersectionOptions extends IntersectionObserverInit {\n  element?: Element\n  dispatchEvent?: boolean\n  eventPrefix?: boolean | string\n}\n\nconst defaultOptions = {\n  dispatchEvent: true,\n  eventPrefix: true,\n}\n\nexport const useIntersection = (controller: IntersectionComposableController, options: IntersectionOptions = {}) => {\n  const { dispatchEvent, eventPrefix } = Object.assign({}, defaultOptions, options)\n  const targetElement: Element = options?.element || controller.element\n\n  const callback = (entries: IntersectionObserverEntry[]) => {\n    const [entry] = entries\n    if (entry.isIntersecting) {\n      dispatchAppear(entry)\n    } else if (controller.isVisible) {\n      dispatchDisappear(entry)\n    }\n  }\n\n  const dispatchAppear = (entry: IntersectionObserverEntry) => {\n    controller.isVisible = true\n    method(controller, 'appear').call(controller, entry)\n\n    // emit a custom \"appear\" event\n    if (dispatchEvent) {\n      const eventName = composeEventName('appear', controller, eventPrefix)\n\n      const appearEvent = extendedEvent(eventName, null, { controller, entry })\n      targetElement.dispatchEvent(appearEvent)\n    }\n  }\n\n  const dispatchDisappear = (entry: IntersectionObserverEntry) => {\n    controller.isVisible = false\n    method(controller, 'disappear').call(controller, entry)\n\n    // emit a custom \"disappear\" event\n    if (dispatchEvent) {\n      const eventName = composeEventName('disappear', controller, eventPrefix)\n\n      const disappearEvent = extendedEvent(eventName, null, { controller, entry })\n      targetElement.dispatchEvent(disappearEvent)\n    }\n  }\n\n  // keep a copy of the current disconnect() function of the controller\n  // to support composing several behaviors\n  const controllerDisconnect = controller.disconnect.bind(controller)\n\n  const observer = new IntersectionObserver(callback, options)\n\n  const observe = () => {\n    observer.observe(targetElement)\n  }\n\n  const unobserve = () => {\n    observer.unobserve(targetElement)\n  }\n\n  Object.assign(controller, {\n    isVisible: false,\n    disconnect() {\n      unobserve()\n      controllerDisconnect()\n    },\n  })\n\n  observe()\n\n  return [observe, unobserve] as const\n}\n","import { Controller, Context } from 'stimulus'\nimport { useIntersection, IntersectionOptions } from './use-intersection'\n\nexport class IntersectionComposableController extends Controller {\n  isVisible: boolean = false\n  declare appear?: (entry: IntersectionObserverEntry) => void\n  declare disappear?: (entry: IntersectionObserverEntry) => void\n}\n\nexport class IntersectionController extends IntersectionComposableController {\n  options?: IntersectionOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useIntersection(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n\n}\n","import { LazyLoadComposableController } from './lazy-load-controller'\nimport { method } from '../support/index'\n\nexport const useLazyLoad = (controller: LazyLoadComposableController, options?: IntersectionObserverInit) => {\n  const callback = (entries: IntersectionObserverEntry[]) => {\n    const [entry] = entries\n    if (entry.isIntersecting && !controller.isLoaded) {\n      handleAppear(entry)\n    }\n  }\n\n  const handleAppear = (entry: IntersectionObserverEntry) => {\n    const src = controller.data.get('src')\n    if (!src) return\n\n    const imageElement = <HTMLImageElement>controller.element\n    controller.isLoading = true\n    method(controller, 'loading').call(controller, src)\n    imageElement.onload = () => {\n      handleLoaded(src)\n    }\n\n    imageElement.src = src\n  }\n\n  const handleLoaded = (src: string) => {\n    controller.isLoading = false\n    controller.isLoaded = true\n    method(controller, 'loaded').call(controller, src)\n  }\n\n  // keep a copy of the current disconnect() function of the controller to not override it\n  const controllerDisconnect = controller.disconnect.bind(controller)\n\n  const observer = new IntersectionObserver(callback, options)\n\n  const observe = () => {\n    observer.observe(controller.element)\n  }\n\n  const unobserve = () => {\n    observer.unobserve(controller.element)\n  }\n\n  Object.assign(controller, {\n    isVisible: false,\n    disconnect() {\n      unobserve()\n      controllerDisconnect()\n    },\n  })\n\n  observe()\n\n  return [observe, unobserve] as const\n}\n","import { Controller, Context } from 'stimulus'\nimport { useLazyLoad } from './useLazyLoad'\n\nexport class LazyLoadComposableController extends Controller {\n  isLoading: boolean = false\n  isLoaded: boolean = false\n  declare loading?: (src: string) => void\n  declare loaded?: (src: string) => void\n}\n\nexport class LazyLoadController extends LazyLoadComposableController {\n  options: IntersectionObserverInit = { rootMargin: '10%' }\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useLazyLoad(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n\n}\n","import { composeEventName, extendedEvent, method } from '../support/index'\nimport { ResizeComposableController } from './resize-controller'\n\nexport interface ResizeOptions {\n  element?: Element\n  dispatchEvent?: boolean\n  eventPrefix?: boolean | string\n}\n\nconst defaultOptions = {\n  dispatchEvent: true,\n  eventPrefix: true,\n}\n\nexport const useResize = (controller: ResizeComposableController, options: ResizeOptions = {}) => {\n  const { dispatchEvent, eventPrefix } = Object.assign({}, defaultOptions, options)\n  const targetElement: Element = options?.element || controller.element\n\n  const callback = (entries: ResizeObserverEntry[]) => {\n    const [entry] = entries\n    method(controller, 'resize').call(controller, entry.contentRect)\n\n    // emit a custom \"controllerIdentifier:resize\" event\n    if (dispatchEvent) {\n      const eventName = composeEventName('resize', controller, eventPrefix)\n      const appearEvent = extendedEvent(eventName, null, {\n        controller,\n        entry,\n      })\n      targetElement.dispatchEvent(appearEvent)\n    }\n  }\n\n  const controllerDisconnect = controller.disconnect.bind(controller)\n\n  const observer = new ResizeObserver(callback)\n\n  const observe = () => {\n    observer.observe(targetElement)\n  }\n  const unobserve = () => {\n    observer.unobserve(targetElement)\n  }\n\n  Object.assign(controller, {\n    disconnect() {\n      unobserve()\n      controllerDisconnect()\n    },\n  })\n\n  observe()\n\n  return [observe, unobserve] as const\n}\n","import { Controller, Context } from 'stimulus'\nimport { useResize, ResizeOptions } from './use-resize'\n\nexport class ResizeComposableController extends Controller {\n  declare resize?: (contentRect: DOMRectReadOnly) => void\n}\n\nexport class ResizeController extends ResizeComposableController {\n  options?: ResizeOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useResize(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n}\n","import { composeEventName, extendedEvent, isElementInViewport } from '../support/index'\nimport { ClickOutsideComposableController } from './click-outside-controller'\n\nexport interface ClickOutsideOptions {\n  element?: Element\n  events?: string[]\n  onlyVisible?: boolean\n  dispatchEvent?: boolean\n  eventPrefix?: boolean | string\n}\n\nconst defaultOptions = {\n  events: ['click', 'touchend'],\n  onlyVisible: true,\n  dispatchEvent: true,\n  eventPrefix: true,\n}\n\nexport const useClickOutside = (controller: ClickOutsideComposableController, options: ClickOutsideOptions = {}) => {\n  const { onlyVisible, dispatchEvent, events, eventPrefix } = Object.assign({}, defaultOptions, options)\n\n  const onEvent = (event: Event) => {\n    const targetElement: Element = options?.element || controller.element\n\n    if (targetElement.contains(event.target as Node) || (!isElementInViewport(targetElement) && onlyVisible)) {\n      return\n    }\n\n    // call the clickOutside method of the Stimulus controller\n    if (controller.clickOutside) {\n      controller.clickOutside(event)\n    }\n\n    // emit a custom event\n    if (dispatchEvent) {\n      const eventName = composeEventName('click:outside', controller, eventPrefix)\n\n      const clickOutsideEvent = extendedEvent(eventName, event, { controller })\n      targetElement.dispatchEvent(clickOutsideEvent)\n    }\n  }\n\n  const observe = () => {\n    events?.forEach(event => {\n      window.addEventListener(event, onEvent, false)\n    })\n  }\n\n  const unobserve = () => {\n    events?.forEach(event => {\n      window.removeEventListener(event, onEvent, false)\n    })\n  }\n\n  // keep a copy of the current disconnect() function of the controller\n  // to support composing several behaviors\n  const controllerDisconnect = controller.disconnect.bind(controller)\n\n  Object.assign(controller, {\n    disconnect() {\n      unobserve()\n      controllerDisconnect()\n    },\n  })\n\n  observe()\n\n  return [observe, unobserve] as const\n}\n","import { Context, Controller } from 'stimulus'\nimport { ClickOutsideOptions, useClickOutside } from './use-click-outside'\n\nexport class ClickOutsideComposableController extends Controller {\n  declare clickOutside?: (event: Event) => void\n}\n\nexport class ClickOutsideController extends ClickOutsideComposableController {\n  options?: ClickOutsideOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useClickOutside(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n}\n","import { Controller } from 'stimulus'\nimport { Logger } from \"./logger\"\n\nexport interface StimulusUseOptions {\n  debug?: boolean\n  logger?: Logger\n}\n\nconst defaultOptions = {\n  debug: false,\n  logger: console\n}\n\nexport class StimulusUse {\n  controller: Controller\n  controllerInitialize: Function\n  controllerConnect: Function\n  controllerDisconnect: Function\n  debug: boolean\n  logger: Logger\n  controllerId: string | undefined\n\n  constructor(controller: Controller, options: StimulusUseOptions = {}) {\n    this.debug = options?.debug ?? (controller.application as any).stimulusUseDebug ?? defaultOptions.debug\n    this.logger = options?.logger ?? defaultOptions.logger\n    this.controller = controller\n    this.controllerId = controller.element.id || (controller.element as HTMLElement).dataset.id\n\n    // make copies of lifecycle functions\n    this.controllerInitialize = controller.initialize.bind(controller)\n    this.controllerConnect = controller.connect.bind(controller)\n    this.controllerDisconnect = controller.disconnect.bind(controller)\n  }\n\n  log = (functionName: string, args: any): void => {\n    if (!this.debug) return\n\n    this.logger.groupCollapsed(`%c${this.controller.identifier} %c#${functionName}`, 'color: #3B82F6', 'color: unset')\n    this.logger.log({\n      controllerId: this.controllerId,\n      ...args\n    })\n    this.logger.groupEnd()\n  }\n}\n","import { composeEventName } from '../support/index'\nimport { Controller } from 'stimulus'\nimport { StimulusUse, StimulusUseOptions } from '../stimulus_use'\n\nexport interface DispatchOptions extends StimulusUseOptions {\n  element?: Element\n  eventPrefix?: boolean | string\n  bubbles?: boolean\n  cancelable?: boolean\n}\n\nconst defaultOptions = {\n  eventPrefix: true,\n  bubbles: true,\n  cancelable: true,\n}\n\nexport class UseDispatch extends StimulusUse {\n  targetElement: Element\n  eventPrefix: boolean | string\n  bubbles: boolean\n  cancelable: boolean\n\n  constructor(controller: Controller, options: DispatchOptions = {}) {\n    super(controller, options)\n\n    this.targetElement = options.element ?? controller.element\n    this.eventPrefix = options.eventPrefix ?? defaultOptions.eventPrefix\n    this.bubbles = options.bubbles ?? defaultOptions.bubbles\n    this.cancelable = options.cancelable ?? defaultOptions.cancelable\n\n    this.enhanceController()\n  }\n\n  dispatch = (eventName: string, detail = {}): CustomEvent => {\n    const { controller, targetElement, eventPrefix, bubbles, cancelable, log } = this\n\n    // includes the emitting controller in the event detail\n    Object.assign(detail, { controller })\n\n    const eventNameWithPrefix = composeEventName(eventName, this.controller, eventPrefix)\n\n    // creates the custom event\n    const event = new CustomEvent(eventNameWithPrefix, {\n      detail,\n      bubbles,\n      cancelable,\n    })\n\n    // dispatch the event from the given element or by default from the root element of the controller\n    targetElement.dispatchEvent(event)\n\n    log(\"dispatch\", { eventName: eventNameWithPrefix, detail, bubbles, cancelable })\n\n    return event\n  }\n\n  private enhanceController() {\n    Object.assign(this.controller, { dispatch: this.dispatch })\n  }\n}\n\nexport const useDispatch = (controller: Controller, options: DispatchOptions = {}): UseDispatch => {\n  return new UseDispatch(controller, options)\n}\n","import { Controller } from 'stimulus'\nimport { useDispatch, DispatchOptions } from '../use-dispatch/index'\n\nexport const useApplication = (controller: Controller, options: DispatchOptions= {}) => {\n  // getter to detect Turbolink preview\n  Object.defineProperty(controller, 'isPreview', {\n    get(): boolean {\n      return document.documentElement.hasAttribute('data-turbolinks-preview')\n    },\n  })\n\n  // getter to get the csrf token\n  Object.defineProperty(controller, 'csrfToken', {\n    get(): boolean {\n      return this.metaValue('csrf-token')\n    },\n  })\n\n  useDispatch(controller, options)\n\n  Object.assign(controller, {\n    metaValue(name: string) {\n      const element = document.head.querySelector(`meta[name=\"${name}\"]`)\n      return element && element.getAttribute('content')\n    },\n  })\n}\n","import { Controller, Context } from 'stimulus'\nimport { useApplication } from './use-application'\nimport { DispatchOptions } from \"../use-dispatch\"\n\nexport class ApplicationController extends Controller {\n  options?: DispatchOptions\n  readonly isPreview: boolean = false\n  readonly csrfToken: string = ''\n\n\n  constructor(context: Context) {\n    super(context)\n    useApplication(this, this.options)\n  }\n\n  declare metaValue: (name: string) => string\n  declare dispatch: (eventName: String, detail: any) => void\n\n}\n","import { IdleComposableController } from './idle-controller'\nimport { extendedEvent, method, composeEventName } from '../support/index'\n\nconst defaultEvents = ['mousemove', 'mousedown', 'resize', 'keydown', 'touchstart', 'wheel']\nconst oneMinute = 60e3\n\nexport interface IdleOptions {\n  ms?: number\n  initialState?: boolean\n  events?: string[]\n  dispatchEvent?: boolean\n  eventPrefix?: boolean | string\n}\n\nconst defaultOptions = {\n  ms: oneMinute,\n  initialState: false,\n  events: defaultEvents,\n  dispatchEvent: true,\n  eventPrefix: true,\n}\n\nexport const useIdle = (controller: IdleComposableController, options: IdleOptions = {}) => {\n  const { ms, initialState, events, dispatchEvent, eventPrefix } = Object.assign({}, defaultOptions, options)\n\n  let isIdle = initialState\n  let timeout = setTimeout(() => {\n    isIdle = true\n    dispatchAway()\n  }, ms)\n\n  const dispatchAway = (event?: Event) => {\n    const eventName = composeEventName('away', controller, eventPrefix)\n\n    controller.isIdle = true\n    method(controller, 'away').call(controller, event)\n\n    if (dispatchEvent) {\n      const clickOutsideEvent = extendedEvent(eventName, event || null, { controller })\n      controller.element.dispatchEvent(clickOutsideEvent)\n    }\n  }\n\n  const dispatchBack = (event?: Event) => {\n    const eventName = composeEventName('back', controller, eventPrefix)\n\n    controller.isIdle = false\n    method(controller, 'back').call(controller, event)\n\n    if (dispatchEvent) {\n      const clickOutsideEvent = extendedEvent(eventName, event || null, { controller })\n      controller.element.dispatchEvent(clickOutsideEvent)\n    }\n  }\n\n  const onEvent = (event: Event) => {\n    if (isIdle) dispatchBack(event)\n\n    isIdle = false\n    clearTimeout(timeout)\n\n    timeout = setTimeout(() => {\n      isIdle = true\n      dispatchAway(event)\n    }, ms)\n  }\n\n  const onVisibility = (event: Event) => {\n    if (!document.hidden) onEvent(event)\n  }\n\n  if (isIdle) {\n    dispatchAway()\n  } else {\n    dispatchBack()\n  }\n\n  const controllerDisconnect = controller.disconnect.bind(controller)\n  const observe = () => {\n    events.forEach(event => {\n      window.addEventListener(event, onEvent)\n    })\n    document.addEventListener('visibilitychange', onVisibility)\n  }\n\n  const unobserve = () => {\n    events.forEach(event => {\n      window.removeEventListener(event, onEvent)\n    })\n    document.removeEventListener('visibilitychange', onVisibility)\n  }\n\n  Object.assign(controller, {\n    disconnect() {\n      unobserve()\n      controllerDisconnect()\n    },\n  })\n\n  observe()\n\n  return [observe, unobserve] as const\n}\n","import { Controller, Context } from 'stimulus'\nimport { IdleOptions, useIdle } from './use-idle'\n\nexport class IdleComposableController extends Controller {\n  isIdle: boolean = false\n  declare away?: () => void\n  declare back?: () => void\n}\n\nexport class IdleController extends IdleComposableController {\n  options?: IdleOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useIdle(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n\n}\n","import { StimulusUse, StimulusUseOptions } from '../stimulus_use'\nimport { composeEventName, extendedEvent, method } from '../support/index'\nimport { VisibilityComposableController } from './visibility-controller'\n\nexport interface VisibilityOptions extends StimulusUseOptions {\n  dispatchEvent?: boolean\n  eventPrefix?: boolean | string\n}\n\nconst defaultOptions = {\n  dispatchEvent: true,\n  eventPrefix: true,\n}\n\nexport class UseVisibility extends StimulusUse {\n  controller: VisibilityComposableController\n  eventPrefix!: boolean | string\n  dispatchEvent!: boolean\n\n  constructor(controller: VisibilityComposableController, options: VisibilityOptions = {}) {\n    super(controller, options)\n    const { dispatchEvent, eventPrefix } = Object.assign({}, defaultOptions, options)\n    Object.assign(this, { dispatchEvent, eventPrefix })\n\n    this.controller = controller\n\n    const disconnect = () => {\n      this.unobserve()\n      this.controllerDisconnect()\n    }\n\n    Object.assign(controller, { disconnect })\n\n    // triggers initial callback on connect\n    this.handleVisibilityChange()\n\n    this.observe()\n  }\n\n  observe = () => {\n    this.controller.isVisible = !document.hidden\n    document.addEventListener('visibilitychange', this.handleVisibilityChange)\n  }\n\n  unobserve = () => {\n    document.removeEventListener('visibilitychange', this.handleVisibilityChange)\n  }\n\n  // private\n  private becomesInvisible = (event?: Event) => {\n    const eventName = composeEventName('invisible', this.controller, this.eventPrefix)\n\n    this.controller.isVisible = false\n    method(this.controller, 'invisible').call(this.controller)\n    this.log('invisible', { isVisible: false })\n\n    this.dispatch(eventName, event)\n  }\n\n  private becomesVisible = (event?: Event) => {\n    const eventName = composeEventName('visible', this.controller, this.eventPrefix)\n\n    this.controller.isVisible = true\n    method(this.controller, 'visible').call(this.controller)\n    this.log('visible', { isVisible: true })\n\n    this.dispatch(eventName, event)\n  }\n\n  private dispatch = (eventName: string, event?: Event) => {\n    if (this.dispatchEvent) {\n      const detail = { controller: this.controller, isVisible: this.controller.isVisible }\n      const visibilityEvent = extendedEvent(eventName, event || null, detail)\n      this.controller.element.dispatchEvent(visibilityEvent)\n      this.log('dispatchEvent', { eventName, ...detail })\n    }\n  }\n\n  private handleVisibilityChange = (event?: Event) => {\n    if (document.hidden) {\n      this.becomesInvisible(event)\n    } else {\n      this.becomesVisible(event)\n    }\n  }\n}\n\nexport const useVisibility = (controller: VisibilityComposableController, options: VisibilityOptions = {}) => {\n  const observer = new UseVisibility(controller, options)\n  return [observer.observe, observer.unobserve] as const\n}\n","import { Controller, Context } from 'stimulus'\nimport { useVisibility, VisibilityOptions } from './use-visibility'\n\nexport class VisibilityComposableController extends Controller {\n  isVisible: boolean = false\n  declare visible?: () => void\n  declare invisible?: () => void\n}\n\nexport class VisibilityController extends VisibilityComposableController {\n  options?: VisibilityOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useVisibility(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n\n}\n","import { StimulusUse, StimulusUseOptions } from '../stimulus_use'\nimport { method } from '../support/index'\nimport { HoverComposableController } from './hover-controller'\n\nexport interface HoverOptions extends StimulusUseOptions {\n  element?: Element\n}\n\nexport class UseHover extends StimulusUse {\n  controller: HoverComposableController\n  targetElement: Element\n\n  constructor(controller: HoverComposableController, options: HoverOptions = {}) {\n    super(controller, options)\n    this.targetElement = options?.element || controller.element\n    this.controller = controller\n    this.enhanceController()\n    this.observe()\n  }\n\n  observe = () => {\n    this.targetElement.addEventListener('mouseenter', this.onEnter)\n    this.targetElement.addEventListener('mouseleave', this.onLeave)\n  }\n\n  unobserve = () => {\n    this.targetElement.removeEventListener('mouseenter', this.onEnter)\n    this.targetElement.removeEventListener('mouseleave', this.onLeave)\n  }\n\n  private onEnter = () => {\n    method(this.controller, 'mouseEnter').call(this.controller)\n    this.log('mouseEnter', { hover: true })\n  }\n\n  private onLeave = () => {\n    method(this.controller, 'mouseLeave').call(this.controller)\n    this.log('mouseLeave', { hover: false })\n  }\n\n  private enhanceController() {\n    const controllerDisconnect = this.controller.disconnect.bind(this.controller)\n\n    const disconnect = () => {\n      this.unobserve()\n      controllerDisconnect()\n    }\n\n    Object.assign(this.controller, { disconnect })\n  }\n}\n\nexport const useHover = (controller: HoverComposableController, options: HoverOptions = {}) => {\n  const observer = new UseHover(controller, options)\n  return [observer.observe, observer.unobserve] as const\n}\n","import { Context, Controller } from 'stimulus'\nimport { HoverOptions, useHover } from './use-hover'\n\nexport class HoverComposableController extends Controller {\n  declare mouseEnter?: () => void;\n  declare mouseLeave?: () => void;\n}\nexport class HoverController extends HoverComposableController {\n  options?: HoverOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useHover(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void;\n  declare unobserve: () => void;\n}\n","import { StimulusUse, StimulusUseOptions } from '../stimulus_use'\nimport { method } from '../support/index'\nimport { MutationComposableController } from './mutation-controller'\n\nexport interface MutationControllerOptions {\n  element?: Element\n}\n\nexport interface MutationOptions extends MutationObserverInit, MutationControllerOptions, StimulusUseOptions {\n}\n\nexport class UseMutation extends StimulusUse {\n  controller: MutationComposableController\n  observer: MutationObserver\n  targetElement: Element\n  options: MutationOptions\n\n  constructor(controller: MutationComposableController, options: MutationOptions = {}) {\n    super(controller, options)\n\n    this.targetElement = options?.element || controller.element\n    this.controller = controller\n    this.options = options\n    this.observer = new MutationObserver(this.mutation)\n\n    this.enhanceController()\n    this.observe()\n  }\n\n  observe = () => {\n   try {\n      this.observer.observe(this.targetElement, this.options)\n    } catch (error) {\n      this.controller.application.handleError(error,\"At a minimum, one of childList, attributes, and/or characterData must be true\",{})\n    }\n  }\n\n  unobserve = () => {\n    this.observer.disconnect()\n  }\n\n  private mutation = (entries: MutationRecord[]) => {\n    method(this.controller, 'mutate').call(this.controller, entries)\n    this.log('mutate', { entries })\n  }\n\n  private enhanceController() {\n    const controllerDisconnect = this.controller.disconnect.bind(this.controller)\n    const disconnect = () => {\n      this.unobserve()\n      controllerDisconnect()\n    }\n    Object.assign(this.controller, { disconnect })\n  }\n}\n\nexport const useMutation = (controller: MutationComposableController, options: MutationOptions = {}) => {\n  const observer = new UseMutation(controller, options)\n  return [observer.observe, observer.unobserve] as const\n}\n","import { Context, Controller } from 'stimulus'\nimport { MutationOptions, useMutation } from './use-mutation'\n\nexport class MutationComposableController extends Controller {\n  declare mutate?: (entries: MutationRecord[]) => void\n}\n\nexport class MutationController extends MutationComposableController {\n  options?: MutationOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useMutation(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n\n}\n","import { StimulusUse, StimulusUseOptions } from '../stimulus_use'\nimport { method } from '../support/index'\nimport { TargetMutationComposableController } from './target-mutation-controller'\n\nexport interface TargetMutationOptions extends StimulusUseOptions {\n  targets?: string[]\n}\n\nexport class UseTargetMutation extends StimulusUse {\n  controller: TargetMutationComposableController\n  observer: MutationObserver\n  targetElement: Node\n  identifier: string\n  identifierPrefix: string\n  targets: string[]\n  prefixedTargets: string[]\n  options: TargetMutationOptions\n  targetSelector: string\n  scopedTargetSelector: string\n\n  constructor(controller: TargetMutationComposableController, options: TargetMutationOptions = {}) {\n    super(controller, options)\n\n    this.controller = controller\n    this.options = options\n    this.targetElement = controller.element\n    this.identifier = controller.scope.identifier\n    this.identifierPrefix = `${this.identifier}.`\n    this.targetSelector = controller.scope.schema.targetAttribute\n    this.scopedTargetSelector = `data-${this.identifier}-target` //TODO: If/When stimulus 2.0 adds the identifier scoped targetAttribute to the schema, use that here instead\n    // @ts-ignore\n    this.targets = options.targets || controller.constructor.targets\n    this.prefixedTargets = this.targets.map((target) => `${this.identifierPrefix}${target}`)\n    this.observer = new MutationObserver(this.mutation)\n\n    this.enhanceController()\n    this.observe()\n  }\n\n  observe = () => {\n    this.observer.observe(\n      this.targetElement,\n      {\n        subtree: true,\n        characterData: true,\n        childList: true,\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: [this.targetSelector, this.scopedTargetSelector]\n      }\n    )\n  }\n\n  unobserve = () => {\n    this.observer.disconnect()\n  }\n\n  mutation = (entries: MutationRecord[]) => {\n    for (const mutation of entries) {\n      switch (mutation.type) {\n        case 'attributes':\n          let newValue = (mutation.target as Element).getAttribute(mutation.attributeName as string)\n          let oldValue = mutation.oldValue\n\n          // If this was an attribute change, and the attribute change resulted in a target changing\n          if (mutation.attributeName === this.targetSelector || mutation.attributeName === this.scopedTargetSelector) {\n            // Filter out any targets that don't belong to this controller\n            let oldTargets = this.targetsUsedByThisController(oldValue)\n            let newTargets = this.targetsUsedByThisController(newValue)\n            let removedTargets = oldTargets.filter(target => !newTargets.includes(target)) // Get only the oldTargets that dont occur in newTargets, thus, removed\n            let addedTargets = newTargets.filter(target => !oldTargets.includes(target)) // Get only the newTargets that dont occur in oldTargets - thus, added\n            // Fire updates for each changed target on the controller\n            removedTargets.forEach(target => this.targetRemoved(this.stripIdentifierPrefix(target), mutation.target, 'attributeChange'))\n            addedTargets.forEach(target => this.targetAdded(this.stripIdentifierPrefix(target), mutation.target, 'attributeChange'))\n          }\n\n          break\n        case 'characterData':\n          let nodule = this.findTargetInAncestry(mutation.target)\n          if (nodule == null) {\n            return\n          } else {\n            let supportedTargets = this.targetsUsedByThisControllerFromNode(nodule)\n            supportedTargets.forEach((target: string) => {\n              this.targetChanged(this.stripIdentifierPrefix(target), nodule!, 'domMutation')\n            })\n          }\n          break\n        case 'childList':\n          let { addedNodes, removedNodes } = mutation\n          addedNodes.forEach((node: Node) => this.processNodeDOMMutation(node, this.targetAdded))\n          removedNodes.forEach((node: Node) => this.processNodeDOMMutation(node, this.targetRemoved))\n          break\n      }\n    }\n  }\n\n  private processNodeDOMMutation(node: Node, initialChangeModeAssumption: (name: string, node: Node, trigger: string) => void) {\n    let nodule: Node | null = node\n    let change = initialChangeModeAssumption\n    let supportedTargets: string[] = []\n    if (nodule.nodeName == '#text' || this.targetsUsedByThisControllerFromNode(nodule).length == 0) {\n      change = this.targetChanged\n      nodule = this.findTargetInAncestry(node)\n    } else {\n      supportedTargets = this.targetsUsedByThisControllerFromNode(nodule)\n    }\n    if (nodule == null) {\n      return\n    } else if (supportedTargets.length == 0) {\n      supportedTargets = this.targetsUsedByThisControllerFromNode(nodule)\n    }\n\n    supportedTargets.forEach((target: string) => {\n      change.call(this, this.stripIdentifierPrefix(target), nodule!, 'domMutation')\n    })\n  }\n\n  private findTargetInAncestry(node: Node): Node | null {\n    let nodule = node\n    let supportedTargets: string[] = []\n    if (nodule.nodeName != '#text') {\n      supportedTargets = this.targetsUsedByThisControllerFromNode(nodule)\n    } else {\n    }\n\n    // Traverse up the node tree until we find a target, or the controller root element\n    while (nodule.parentNode !== null && nodule.parentNode != this.targetElement && supportedTargets.length == 0) {\n      nodule = nodule.parentNode\n      if (nodule.nodeName !== '#text') {\n        let supportedTargets = this.targetsUsedByThisControllerFromNode(nodule)\n        if (supportedTargets.length > 0) {\n          // If this node has one of the watched targets on it, it's the one we want\n          return nodule\n        } else {\n        }\n      }\n    }\n    if (nodule.nodeName == '#text') {\n      return null\n    }\n    if (nodule.parentNode == null) {\n      return null\n    }\n    if (nodule.parentNode == this.targetElement) {\n      // Double and triple check that we aren't throwing away a target just because it's parent is the controller root\n      if (this.targetsUsedByThisControllerFromNode(nodule).length > 0) {\n        return nodule\n      }\n      return null\n    }\n    return null\n  }\n\n  private targetAdded(name: string, node: Node, trigger: string) {\n    let targetCallback = `${name}TargetAdded`\n    this.controller[targetCallback] && method(this.controller, targetCallback).call(this.controller, node)\n    this.log('targetAdded', { target: name, node, trigger })\n  }\n\n  private targetRemoved(name: string, node: Node, trigger: string) {\n    let targetCallback = `${name}TargetRemoved`\n    this.controller[targetCallback] && method(this.controller, targetCallback).call(this.controller, node)\n    this.log('targetRemoved', { target: name, node, trigger })\n  }\n\n  private targetChanged(name: string, node: Node, trigger: string) {\n    let targetCallback = `${name}TargetChanged`\n    this.controller[targetCallback] && method(this.controller, targetCallback).call(this.controller, node)\n    this.log('targetChanged', { target: name, node, trigger })\n  }\n\n  private targetsUsedByThisControllerFromNode(node: Node): string[] {\n    if (node.nodeName == \"#text\") {\n      // Failsafe, just in case we try processing a text node\n      return []\n    }\n    // Extracts from the node, the target string, targetsUsedByThisController filters it, returns the array of supported target names\n    let nodeElement = node as Element\n    return this.targetsUsedByThisController(nodeElement.getAttribute(this.scopedTargetSelector) || nodeElement.getAttribute(this.targetSelector))\n  }\n\n  private targetsUsedByThisController(targetStr: string | null) {\n    // Filters out any targets that don't belong to this  controller and returns the array of supported target names\n    targetStr = targetStr || ''\n    let targetsToCheck = this.stripIdentifierPrefix(targetStr).split(' ')\n    return this.targets.filter((n) => targetsToCheck.indexOf(n) !== -1)\n  }\n\n  private stripIdentifierPrefix(target: string): string {\n    return target.replace(new RegExp(this.identifierPrefix, 'g'), '')\n  }\n\n  private enhanceController() {\n    const controllerDisconnect = this.controller.disconnect.bind(this.controller)\n    const disconnect = () => {\n      this.unobserve()\n      controllerDisconnect()\n    }\n    Object.assign(this.controller, { disconnect })\n  }\n}\n\nexport const useTargetMutation = (controller: TargetMutationComposableController, options: TargetMutationOptions = {}) => {\n  const observer = new UseTargetMutation(controller, options)\n  return [observer.observe, observer.unobserve]\n}\n","import { Context, Controller } from 'stimulus'\nimport { TargetMutationOptions, useTargetMutation } from './use-target-mutation'\n\nexport class TargetMutationComposableController extends Controller {\n  [index: string]: any;\n}\n\nexport class TargetMutationController extends TargetMutationComposableController {\n\n  options!: TargetMutationOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useTargetMutation(this, this.options)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n\n}\n","import { WindowResizeComposableController } from './window-resize-controller'\nimport { method } from '../support/index'\n\nexport interface WindowResizePayload {\n  height: number,\n  width: number,\n  event?: Event\n}\n\nexport const useWindowResize = (controller: WindowResizeComposableController) => {\n\n  const callback = (event?: Event) => {\n    const { innerWidth, innerHeight } = window\n\n    const payload: WindowResizePayload = {\n      height: innerHeight || Infinity,\n      width: innerWidth || Infinity,\n      event\n    }\n\n    method(controller, 'windowResize').call(controller, payload)\n  }\n\n  const controllerDisconnect = controller.disconnect.bind(controller)\n\n  const observe = () => {\n    window.addEventListener('resize', callback)\n    callback()\n  }\n\n  const unobserve = () => {\n    window.removeEventListener('resize', callback)\n  }\n\n  Object.assign(controller, {\n    disconnect() {\n      unobserve()\n      controllerDisconnect()\n    },\n  })\n\n  observe()\n\n  return [observe, unobserve] as const\n}\n","import { Controller, Context } from 'stimulus'\nimport { useWindowResize, WindowResizePayload } from './use-window-resize'\n\nexport class WindowResizeComposableController extends Controller {\n  declare windowResize?: (payload: WindowResizePayload) => void\n}\n\nexport class WindowResizeController extends WindowResizeComposableController {\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      const [observe, unobserve] = useWindowResize(this)\n      Object.assign(this, { observe, unobserve })\n    })\n  }\n\n  declare observe: () => void\n  declare unobserve: () => void\n\n}\n","import { Controller } from 'stimulus'\n\nexport interface DebounceOptions {\n  wait?: number\n  name?: string\n}\n\nclass DebounceController extends Controller {\n  static debounces: string[] | DebounceOptions[] = []\n}\n\nconst defaultWait = 200\n\nconst debounce = (fn: Function, wait: number = defaultWait) => {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n\n  return function (this: any): any {\n    const args = arguments;\n    const context = this;\n\n    const callback = () => fn.apply(context, args)\n    if (timeoutId) {\n      clearTimeout(timeoutId)\n    }\n    timeoutId = setTimeout(callback, wait)\n  }\n}\n\nexport const useDebounce = (controller: DebounceController, options: DebounceOptions) => {\n  const constructor = controller.constructor as any\n\n  constructor.debounces?.forEach((func: string | DebounceOptions) => {\n    if (typeof func === \"string\") {\n      (controller as any)[func] = debounce((controller as any)[func] as Function, options?.wait)\n    }\n\n    if (typeof func === \"object\") {\n      const { name, wait } = func as DebounceOptions\n      if (!name) return\n      (controller as any)[name] = debounce((controller as any)[name] as Function, wait || options?.wait)\n    }\n  })\n}\n","import { Controller } from 'stimulus'\n\nexport interface ThrottleOptions {\n  wait?: number\n  name?: string\n}\n\nclass ThrottleController extends Controller {\n  static throttles: string[] | ThrottleOptions[] = []\n}\n\nconst defaultWait = 200\n\nexport function throttle(func: Function, wait: number = defaultWait): Function {\n  let inThrottle: boolean;\n\n  return function (this: any): any {\n    const args = arguments;\n    const context = this;\n\n    if (!inThrottle) {\n      inThrottle = true;\n      func.apply(context, args);\n      setTimeout(() => (inThrottle = false), wait);\n    }\n  };\n}\n\nexport const useThrottle = (controller: ThrottleController, options: ThrottleOptions = {}) => {\n  const constructor = controller.constructor as any\n\n  constructor.throttles?.forEach((func: string | ThrottleOptions) => {\n    if (typeof func === \"string\") {\n      (controller as any)[func] = throttle((controller as any)[func] as Function, options?.wait)\n    }\n\n    if (typeof func === \"object\") {\n      const { name, wait } = func as ThrottleOptions\n      if (!name) return\n      (controller as any)[name] = throttle((controller as any)[name] as Function, wait || options?.wait)\n    }\n  })\n}\n","import { Controller } from 'stimulus'\n\nexport interface MetaOptions {\n  suffix: boolean\n}\n\nconst defineMetaGetter = (controller: Controller, metaName: string, suffix: boolean) => {\n  const getterName = suffix ? `${camelize(metaName)}Meta` : camelize(metaName)\n\n  Object.defineProperty(controller, getterName, {\n    get(): any {\n      return typeCast(metaValue(metaName))\n    },\n  })\n}\n\nfunction metaValue(name: string) {\n  const element = document.head.querySelector(`meta[name=\"${name}\"]`)\n  return element && element.getAttribute('content')\n}\n\nfunction typeCast(value: any): any {\n  try {\n    return JSON.parse(value)\n  } catch (o_O) {\n    return value\n  }\n}\n\nfunction camelize(value: string) {\n  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase())\n}\n\nexport const useMeta = (controller: Controller, options: MetaOptions = { suffix: true }) => {\n  const metaNames = (controller.constructor as any).metaNames\n  const suffix = options.suffix\n\n  // defines the individual meta getters\n  metaNames?.forEach((metaName: string) => {\n    defineMetaGetter(controller, metaName, suffix)\n  })\n\n  // define the metas getter to retreive an object with all metas\n  Object.defineProperty(controller, \"metas\", {\n    get(): Record<string, any> {\n      const result: Record<string, any> = {}\n\n      metaNames?.forEach((metaName: string) => {\n        const value = typeCast(metaValue(metaName))\n        if (value !== undefined && value !== null) {\n          result[camelize(metaName)] = value\n        }\n      })\n      return result\n    },\n  })\n}\n","import { TransitionComposableController } from './transition-controller'\n\nexport interface TransitionOptions {\n  element?: Element\n  dispatchEvent?: boolean\n  transitioned?: boolean\n  eventPrefix?: boolean | string\n  enter?: string\n  enterActive?: string\n  enterTo?: string\n  leave?: string\n  leaveActive?: string\n  leaveTo?: string\n  hiddenClass?: string\n}\n\nconst alpineNames: object = {\n  enterClass: \"enter\",\n  enterActiveClass: \"enterStart\",\n  enterToClass: \"enterEnd\",\n  leaveClass: \"leave\",\n  leaveActiveClass: \"leaveStart\",\n  leaveToClass: \"leaveEnd\",\n}\n\nconst defaultOptions = {\n  dispatchEvent: true,\n  eventPrefix: true,\n  transitioned: false,\n  hiddenClass: \"hidden\"\n}\n\nexport const useTransition = (controller: TransitionComposableController, options: TransitionOptions = {}) => {\n  const targetName = (controller.element as HTMLElement).dataset.transitionTarget\n  let targetFromAttribute\n\n  if (targetName) {\n    targetFromAttribute = (controller as any)[`${targetName}Target`]\n  }\n\n  const targetElement = options?.element || targetFromAttribute || controller.element\n\n  // data attributes are only available on HTMLElement and SVGElement\n  if (!((targetElement instanceof HTMLElement) || (targetElement instanceof SVGElement))) return\n  const dataset = targetElement.dataset\n\n  const { transitioned, hiddenClass } = Object.assign(defaultOptions, options)\n\n  const controllerEnter = controller.enter?.bind(controller)\n  const controllerLeave = controller.leave?.bind(controller)\n  const controllerToggleTransition = controller.toggleTransition?.bind(controller)\n\n  async function enter(event?: Event) {\n    if (controller.transitioned) return\n\n    controller.transitioned = true\n    controllerEnter && controllerEnter(event)\n\n    const enterClass = getAttribute(\"enter\", options, dataset)\n    const enterActiveClass = getAttribute(\"enterActive\", options, dataset)\n    const enterToClass = getAttribute(\"enterTo\", options, dataset)\n\n    if (!!hiddenClass) {\n      targetElement.classList.remove(hiddenClass)\n    }\n\n    await transition(targetElement, enterClass, enterActiveClass, enterToClass)\n\n  }\n\n  async function leave(event?: Event) {\n    if (!controller.transitioned) return\n    controller.transitioned = false\n    controllerLeave && controllerLeave(event)\n\n    const leaveClass = getAttribute(\"leave\", options, dataset)\n    const leaveActiveClass = getAttribute(\"leaveActive\", options, dataset)\n    const leaveToClass = getAttribute(\"leaveTo\", options, dataset)\n\n    await transition(targetElement, leaveClass, leaveActiveClass, leaveToClass)\n\n    if (!!hiddenClass) {\n      targetElement.classList.add(hiddenClass)\n    }\n  }\n\n  function toggleTransition(event: Event) {\n    controllerToggleTransition && controllerToggleTransition(event)\n\n    if (controller.transitioned) {\n      leave()\n    } else {\n      enter()\n    }\n  }\n\n  async function transition(element: Element, initialClass: string[], activeClass: string[], toClass: string[]) {\n    element.classList.add(...initialClass);\n    element.classList.add(...activeClass);\n    await nextFrame();\n\n    element.classList.remove(...activeClass);\n    element.classList.add(...toClass);\n\n    await afterTransition(element);\n\n    element.classList.remove(...initialClass);\n  }\n\n  function initialState() {\n    controller.transitioned = transitioned\n    if (transitioned) {\n      if (!!hiddenClass) {\n        targetElement.classList.remove(hiddenClass)\n      }\n      enter()\n    } else {\n      if (!!hiddenClass) {\n        targetElement.classList.add(hiddenClass)\n      }\n      leave()\n    }\n  }\n\n  initialState()\n  Object.assign(controller, { enter, leave, toggleTransition })\n  return [enter, leave, toggleTransition]\n}\n\nfunction getAttribute(name: string, options: TransitionOptions, dataset: DOMStringMap) {\n  const datasetName = `transition${name[0].toUpperCase()}${name.substr(1)}`\n  const datasetAlpineName = (alpineNames as any)[name]\n  const classes = (options as any)[name] || dataset[datasetName] || dataset[datasetAlpineName] || \"\"\n  return classes.split(\" \")\n}\n\nasync function afterTransition(element: Element): Promise<number> {\n  return new Promise(resolve => {\n    const duration = Number(\n      getComputedStyle(element)\n        .transitionDuration\n        .split(\",\")[0]\n        .replace('s', '')\n    ) * 1000\n\n    setTimeout(() => {\n      resolve(duration)\n    }, duration)\n  });\n}\n\nasync function nextFrame() {\n  return new Promise(resolve => {\n    requestAnimationFrame(() => {\n      requestAnimationFrame(resolve);\n    });\n  });\n}\n","import { Controller, Context } from 'stimulus'\nimport { useTransition, TransitionOptions } from './use-transition'\n\nexport class TransitionComposableController extends Controller {\n  transitioned: boolean = false\n\n  declare enter?: (event: Event | undefined) => void\n  declare leave?: (event: Event | undefined) => void\n  declare toggleTransition?: (event: Event | undefined) => void\n}\n\nexport class TransitionController extends TransitionComposableController {\n  options?: TransitionOptions\n\n  constructor(context: Context) {\n    super(context)\n    requestAnimationFrame(() => {\n      useTransition(this, this.options)\n    })\n  }\n\n}\n","import { Controller } from 'stimulus'\n\nconst memoize = (controller: Controller, name: string, value: any) => {\n  Object.defineProperty(controller, name, { value })\n  return value\n}\n\nexport const useMemo = (controller: Controller) => {\n  (controller.constructor as any).memos?.forEach((getter: string) => {\n    memoize(controller, getter, (controller as any)[getter])\n  })\n}\n"],"names":["method","controller","methodName","composeEventName","name","eventPrefix","composedName","identifier","extendedEvent","type","event","detail","bubbles","cancelable","composed","Object","assign","originalEvent","CustomEvent","defaultOptions","dispatchEvent","useIntersection","options","targetElement","element","controllerDisconnect","disconnect","bind","observer","IntersectionObserver","entries","entry","isIntersecting","isVisible","call","eventName","appearEvent","dispatchAppear","disappearEvent","dispatchDisappear","observe","unobserve","IntersectionController","context","_this2","requestAnimationFrame","Controller","useLazyLoad","isLoaded","src","data","get","imageElement","isLoading","onload","handleLoaded","handleAppear","LazyLoadController","rootMargin","_this","useResize","ResizeObserver","contentRect","ResizeController","events","onlyVisible","useClickOutside","onEvent","rect","windowHeight","windowWidth","contains","target","getBoundingClientRect","window","innerHeight","document","documentElement","clientHeight","innerWidth","clientWidth","top","height","left","width","clickOutside","clickOutsideEvent","forEach","addEventListener","removeEventListener","ClickOutsideController","debug","logger","console","StimulusUse","this","functionName","args","groupCollapsed","log","controllerId","groupEnd","_options","application","stimulusUseDebug","_options2","id","dataset","controllerInitialize","initialize","controllerConnect","connect","UseDispatch","eventNameWithPrefix","enhanceController","dispatch","useDispatch","useApplication","defineProperty","hasAttribute","metaValue","head","querySelector","getAttribute","ApplicationController","ms","initialState","useIdle","isIdle","timeout","setTimeout","dispatchAway","dispatchBack","clearTimeout","onVisibility","hidden","IdleController","UseVisibility","handleVisibilityChange","visibilityEvent","becomesInvisible","becomesVisible","useVisibility","VisibilityController","UseHover","onEnter","onLeave","hover","useHover","HoverController","UseMutation","error","handleError","MutationObserver","mutation","useMutation","MutationController","UseTargetMutation","subtree","characterData","childList","attributes","attributeOldValue","attributeFilter","targetSelector","scopedTargetSelector","newValue","attributeName","oldTargets","targetsUsedByThisController","oldValue","newTargets","removedTargets","filter","includes","addedTargets","targetRemoved","stripIdentifierPrefix","targetAdded","nodule","findTargetInAncestry","targetsUsedByThisControllerFromNode","targetChanged","removedNodes","addedNodes","node","processNodeDOMMutation","scope","identifierPrefix","schema","targetAttribute","targets","constructor","prefixedTargets","map","initialChangeModeAssumption","change","supportedTargets","nodeName","length","parentNode","trigger","targetCallback","nodeElement","targetStr","targetsToCheck","split","n","indexOf","replace","RegExp","_this3","useTargetMutation","TargetMutationController","useWindowResize","callback","payload","Infinity","WindowResizeController","debounce","fn","wait","timeoutId","arguments","apply","throttle","func","inThrottle","typeCast","value","JSON","parse","o_O","camelize","_","char","toUpperCase","useMeta","alpineNames","enterClass","enterActiveClass","enterToClass","leaveClass","leaveActiveClass","leaveToClass","transitioned","hiddenClass","useTransition","transition","initialClass","activeClass","toClass","classList","add","Promise","resolve","nextFrame","remove","duration","Number","getComputedStyle","transitionDuration","afterTransition","leave","controllerLeave","enter","controllerEnter","targetFromAttribute","targetName","transitionTarget","HTMLElement","SVGElement","_controller$enter","_controller$leave","controllerToggleTransition","toggleTransition","_controller$toggleTra","datasetName","substr","TransitionController","debounces","memos","getter","memoize","suffix","metaNames","metaName","getterName","defineMetaGetter","result","throttles"],"mappings":"2OAEaA,EAAS,SAACC,EAAwBC,GAC7C,IAAMF,EAAUC,EAAmBC,GACnC,MAAqB,mBAAVF,EACFA,gBAMEG,EAAmB,SAACC,EAAcH,EAAwBI,GACrE,IAAIC,EAAeF,EAMnB,OALoB,IAAhBC,EACFC,EAAkBL,EAAWM,eAAcH,EACX,iBAAhBC,IAChBC,EAAkBD,MAAeD,GAE5BE,GAGIE,EAAgB,SAACC,EAAcC,EAAqBC,SACrBD,GAAS,CAAEE,SAAS,EAAMC,YAAY,EAAMC,UAAU,GAAxFF,IAAAA,QAASC,IAAAA,WAAYC,IAAAA,SAY7B,OAVIJ,GACFK,OAAOC,OAAOL,EAAQ,CAAEM,cAAeP,IAGrB,IAAIQ,YAAYT,EAAM,CACxCG,QAAAA,EACAC,WAAAA,EACAC,SAAAA,EACAH,OAAAA,KCvBEQ,EAAiB,CACrBC,eAAe,EACff,aAAa,GAGFgB,EAAkB,SAACpB,EAA8CqB,kBAAAA,IAAAA,EAA+B,UACpEP,OAAOC,OAAO,GAAIG,EAAgBG,GAAjEF,IAAAA,cAAef,IAAAA,YACjBkB,YAAyBD,YAASE,UAAWvB,EAAWuB,QAuCxDC,EAAuBxB,EAAWyB,WAAWC,KAAK1B,GAElD2B,EAAW,IAAIC,qBAvCJ,SAACC,OACTC,EAASD,KACZC,EAAMC,eAOW,SAACD,GAKtB,GAJA9B,EAAWgC,WAAY,EACvBjC,EAAOC,EAAY,UAAUiC,KAAKjC,EAAY8B,GAG1CX,EAAe,CACjB,IAAMe,EAAYhC,EAAiB,SAAUF,EAAYI,GAEnD+B,EAAc5B,EAAc2B,EAAW,KAAM,CAAElC,WAAAA,EAAY8B,MAAAA,IACjER,EAAcH,cAAcgB,IAf5BC,CAAeN,GACN9B,EAAWgC,WAkBE,SAACF,GAKzB,GAJA9B,EAAWgC,WAAY,EACvBjC,EAAOC,EAAY,aAAaiC,KAAKjC,EAAY8B,GAG7CX,EAAe,CACjB,IAAMe,EAAYhC,EAAiB,YAAaF,EAAYI,GAEtDiC,EAAiB9B,EAAc2B,EAAW,KAAM,CAAElC,WAAAA,EAAY8B,MAAAA,IACpER,EAAcH,cAAckB,IA1B5BC,CAAkBR,IAkC8BT,GAE9CkB,EAAU,WACdZ,EAASY,QAAQjB,IAGbkB,EAAY,WAChBb,EAASa,UAAUlB,IAarB,OAVAR,OAAOC,OAAOf,EAAY,CACxBgC,WAAW,EACXP,sBACEe,IACAhB,OAIJe,IAEO,CAACA,EAASC,2hBCpENC,cAGX,WAAYC,gBACVC,cAAMD,SACNE,sBAAsB,iBACSxB,OAAsBuB,EAAKtB,SAAjDkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QAPrC,6BANA,sEACuB,IADvB,iBAAsDK,eCAzCC,EAAc,SAAC9C,EAA0CqB,GACpE,IA4BMG,EAAuBxB,EAAWyB,WAAWC,KAAK1B,GAElD2B,EAAW,IAAIC,qBA9BJ,SAACC,GACAA,KACNE,iBAAmB/B,EAAW+C,UAKrB,SAACjB,GACpB,IAAMkB,EAAMhD,EAAWiD,KAAKC,IAAI,OAChC,GAAKF,EAAL,CAEA,IAAMG,EAAiCnD,EAAWuB,QAClDvB,EAAWoD,WAAY,EACvBrD,EAAOC,EAAY,WAAWiC,KAAKjC,EAAYgD,GAC/CG,EAAaE,OAAS,YAOH,SAACL,GACpBhD,EAAWoD,WAAY,EACvBpD,EAAW+C,UAAW,EACtBhD,EAAOC,EAAY,UAAUiC,KAAKjC,EAAYgD,GAT5CM,CAAaN,IAGfG,EAAaH,IAAMA,GAfjBO,IA2BgDlC,GAE9CkB,EAAU,WACdZ,EAASY,QAAQvC,EAAWuB,UAGxBiB,EAAY,WAChBb,EAASa,UAAUxC,EAAWuB,UAahC,OAVAT,OAAOC,OAAOf,EAAY,CACxBgC,WAAW,EACXP,sBACEe,IACAhB,OAIJe,IAEO,CAACA,EAASC,IC5CNgB,cAGX,WAAYd,gBACVC,cAAMD,kBAH4B,CAAEe,WAAY,OAIhDb,sBAAsB,iBACSE,OAAkBH,EAAKtB,SAA7CkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QAPrC,6BAPA,sEACuB,EACrBkB,YAAoB,IAFtB,iBAAkDb,eCM5C3B,EAAiB,CACrBC,eAAe,EACff,aAAa,GAGFuD,EAAY,SAAC3D,EAAwCqB,kBAAAA,IAAAA,EAAyB,UAClDP,OAAOC,OAAO,GAAIG,EAAgBG,GAAjEF,IAAAA,cAAef,IAAAA,YACjBkB,YAAyBD,YAASE,UAAWvB,EAAWuB,QAiBxDC,EAAuBxB,EAAWyB,WAAWC,KAAK1B,GAElD2B,EAAW,IAAIiC,eAjBJ,SAAC/B,OACTC,EAASD,KAIhB,GAHA9B,EAAOC,EAAY,UAAUiC,KAAKjC,EAAY8B,EAAM+B,aAGhD1C,EAAe,CACjB,IAAMe,EAAYhC,EAAiB,SAAUF,EAAYI,GACnD+B,EAAc5B,EAAc2B,EAAW,KAAM,CACjDlC,WAAAA,EACA8B,MAAAA,IAEFR,EAAcH,cAAcgB,MAQ1BI,EAAU,WACdZ,EAASY,QAAQjB,IAEbkB,EAAY,WAChBb,EAASa,UAAUlB,IAYrB,OATAR,OAAOC,OAAOf,EAAY,CACxByB,sBACEe,IACAhB,OAIJe,IAEO,CAACA,EAASC,IC9CNsB,cAGX,WAAYpB,gBACVgB,cAAMhB,SACNE,sBAAsB,iBACSe,OAAgBD,EAAKrC,SAA3CkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QAPrC,gGAJgDK,eCQ1C3B,EAAiB,CACrB6C,OAAQ,CAAC,QAAS,YAClBC,aAAa,EACb7C,eAAe,EACff,aAAa,GAGF6D,EAAkB,SAACjE,EAA8CqB,YAAAA,IAAAA,EAA+B,UAC/CP,OAAOC,OAAO,GAAIG,EAAgBG,GAAtF2C,IAAAA,YAAa7C,IAAAA,cAAe4C,IAAAA,OAAQ3D,IAAAA,YAEtC8D,EAAU,SAACzD,SPiBX0D,EAEAC,EACAC,EOnBE/C,YAAyBD,YAASE,UAAWvB,EAAWuB,QAE9D,IAAID,EAAcgD,SAAS7D,EAAM8D,UPc7BJ,EOdsE7C,EPc5DkD,wBAEVJ,EAAgBK,OAAOC,aAAeC,SAASC,gBAAgBC,aAC/DR,EAAeI,OAAOK,YAAcH,SAASC,gBAAgBG,YAE/CZ,EAAKa,KAAOZ,GAAmBD,EAAKa,IAAMb,EAAKc,QAAW,GAC3Dd,EAAKe,MAAQb,GAAkBF,EAAKe,KAAOf,EAAKgB,OAAU,IOpBiBnB,KAKxFhE,EAAWoF,cACbpF,EAAWoF,aAAa3E,GAItBU,GAAe,CACjB,IAAMe,EAAYhC,EAAiB,gBAAiBF,EAAYI,GAE1DiF,EAAoB9E,EAAc2B,EAAWzB,EAAO,CAAET,WAAAA,IAC5DsB,EAAcH,cAAckE,KAI1B9C,EAAU,iBACdwB,GAAAA,EAAQuB,QAAQ,SAAA7E,GACdgE,OAAOc,iBAAiB9E,EAAOyD,GAAS,MAItC1B,EAAY,iBAChBuB,GAAAA,EAAQuB,QAAQ,SAAA7E,GACdgE,OAAOe,oBAAoB/E,EAAOyD,GAAS,MAMzC1C,EAAuBxB,EAAWyB,WAAWC,KAAK1B,GAWxD,OATAc,OAAOC,OAAOf,EAAY,CACxByB,sBACEe,IACAhB,OAIJe,IAEO,CAACA,EAASC,IC5DNiD,cAGX,WAAY/C,gBACVgB,cAAMhB,SACNE,sBAAsB,iBACSqB,OAAsBP,EAAKrC,SAAjDkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QAPrC,gGAJsDK,eCKhD3B,EAAiB,CACrBwE,OAAO,EACPC,OAAQC,SAGGC,EASX,SAAY7F,EAAwBqB,iCAAAA,IAAAA,EAA8B,IAYlEyE,SAAM,SAACC,EAAsBC,GACtBtC,EAAKgC,QAEVhC,EAAKiC,OAAOM,oBAAoBvC,EAAK1D,WAAWM,kBAAiByF,EAAgB,iBAAkB,gBACnGrC,EAAKiC,OAAOO,OACVC,aAAczC,EAAKyC,cAChBH,IAELtC,EAAKiC,OAAOS,aAnBZN,KAAKJ,iCAAQrE,UAAAgF,EAASX,SAAU1F,EAAWsG,YAAoBC,oBAAoBrF,EAAewE,MAClGI,KAAKH,yBAAStE,UAAAmF,EAASb,UAAUzE,EAAeyE,OAChDG,KAAK9F,WAAaA,EAClB8F,KAAKK,aAAenG,EAAWuB,QAAQkF,IAAOzG,EAAWuB,QAAwBmF,QAAQD,GAGzFX,KAAKa,qBAAuB3G,EAAW4G,WAAWlF,KAAK1B,GACvD8F,KAAKe,kBAAoB7G,EAAW8G,QAAQpF,KAAK1B,GACjD8F,KAAKtE,qBAAuBxB,EAAWyB,WAAWC,KAAK1B,ICd9C+G,cAMX,WAAY/G,EAAwBqB,iCAAAA,IAAAA,EAA2B,KAC7DqC,cAAM1D,EAAYqB,mBAUT,SAACa,EAAmBxB,YAAAA,IAAAA,EAAS,eAClBY,IAAAA,cAAelB,IAAAA,YAAaO,IAAAA,QAASC,IAAAA,WAAYsF,IAAAA,IAGrEpF,OAAOC,OAAOL,EAAQ,CAAEV,aAHhBA,aAKR,IAAMgH,EAAsB9G,EAAiBgC,EAAWwB,EAAK1D,WAAYI,GAGnEK,EAAQ,IAAIQ,YAAY+F,EAAqB,CACjDtG,OAAAA,EACAC,QAAAA,EACAC,WAAAA,IAQF,OAJAU,EAAcH,cAAcV,GAE5ByF,EAAI,WAAY,CAAEhE,UAAW8E,EAAqBtG,OAAAA,EAAQC,QAAAA,EAASC,WAAAA,IAE5DH,GA5BPiD,EAAKpC,uBAAgBD,EAAQE,WAAWvB,EAAWuB,QACnDmC,EAAKtD,qBAAciB,EAAQjB,gBAC3BsD,EAAK/C,iBAAUU,EAAQV,YACvB+C,EAAK9C,oBAAaS,EAAQT,eAE1B8C,EAAKuD,gDA0BCA,kBAAA,WACNnG,OAAOC,OAAO+E,KAAK9F,WAAY,CAAEkH,SAAUpB,KAAKoB,eAzCnBrB,GA6CpBsB,EAAc,SAACnH,EAAwBqB,GAClD,gBADkDA,IAAAA,EAA2B,QAClE0F,EAAY/G,EAAYqB,IC5DxB+F,EAAiB,SAACpH,EAAwBqB,YAAAA,IAAAA,EAA0B,IAE/EP,OAAOuG,eAAerH,EAAY,YAAa,CAC7CkD,eACE,OAAOyB,SAASC,gBAAgB0C,aAAa,8BAKjDxG,OAAOuG,eAAerH,EAAY,YAAa,CAC7CkD,eACE,YAAYqE,UAAU,iBAI1BJ,EAAYnH,EAAYqB,GAExBP,OAAOC,OAAOf,EAAY,CACxBuH,mBAAUpH,GACR,IAAMoB,EAAUoD,SAAS6C,KAAKC,4BAA4BtH,QAC1D,OAAOoB,GAAWA,EAAQmG,aAAa,eCnBhCC,cAMX,WAAYjF,gBACVgB,cAAMhB,qBALsB,EACrBgB,YAAoB,GAK3B0D,OAAqB1D,EAAKrC,WAR9B,iBAA2CwB,cCUrC3B,EAAiB,CACrB0G,GAXgB,IAYhBC,cAAc,EACd9D,OAdoB,CAAC,YAAa,YAAa,SAAU,UAAW,aAAc,SAelF5C,eAAe,EACff,aAAa,GAGF0H,EAAU,SAAC9H,EAAsCqB,YAAAA,IAAAA,EAAuB,UAClBP,OAAOC,OAAO,GAAIG,EAAgBG,GAA3FuG,IAAAA,GAAkB7D,IAAAA,OAAQ5C,IAAAA,cAAef,IAAAA,YAE7C2H,IAFQF,aAGRG,EAAUC,WAAW,WACvBF,GAAS,EACTG,KACCN,GAEGM,EAAe,SAACzH,GACpB,IAAMyB,EAAYhC,EAAiB,OAAQF,EAAYI,GAKvD,GAHAJ,EAAW+H,QAAS,EACpBhI,EAAOC,EAAY,QAAQiC,KAAKjC,EAAYS,GAExCU,EAAe,CACjB,IAAMkE,EAAoB9E,EAAc2B,EAAWzB,GAAS,KAAM,CAAET,WAAAA,IACpEA,EAAWuB,QAAQJ,cAAckE,KAI/B8C,EAAe,SAAC1H,GACpB,IAAMyB,EAAYhC,EAAiB,OAAQF,EAAYI,GAKvD,GAHAJ,EAAW+H,QAAS,EACpBhI,EAAOC,EAAY,QAAQiC,KAAKjC,EAAYS,GAExCU,EAAe,CACjB,IAAMkE,EAAoB9E,EAAc2B,EAAWzB,GAAS,KAAM,CAAET,WAAAA,IACpEA,EAAWuB,QAAQJ,cAAckE,KAI/BnB,EAAU,SAACzD,GACXsH,GAAQI,EAAa1H,GAEzBsH,GAAS,EACTK,aAAaJ,GAEbA,EAAUC,WAAW,WACnBF,GAAS,EACTG,EAAazH,IACZmH,IAGCS,EAAe,SAAC5H,GACfkE,SAAS2D,QAAQpE,EAAQzD,IAG5BsH,EACFG,IAEAC,IAGF,IAAM3G,EAAuBxB,EAAWyB,WAAWC,KAAK1B,GAClDuC,EAAU,WACdwB,EAAOuB,QAAQ,SAAA7E,GACbgE,OAAOc,iBAAiB9E,EAAOyD,KAEjCS,SAASY,iBAAiB,mBAAoB8C,IAG1C7F,EAAY,WAChBuB,EAAOuB,QAAQ,SAAA7E,GACbgE,OAAOe,oBAAoB/E,EAAOyD,KAEpCS,SAASa,oBAAoB,mBAAoB6C,IAYnD,OATAvH,OAAOC,OAAOf,EAAY,CACxByB,sBACEe,IACAhB,OAIJe,IAEO,CAACA,EAASC,IC5FN+F,cAGX,WAAY7F,gBACVC,cAAMD,SACNE,sBAAsB,iBACSkF,OAAcnF,EAAKtB,SAAzCkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QAPrC,6BANA,mEACoB,IADpB,iBAA8CK,eCMxC3B,EAAiB,CACrBC,eAAe,EACff,aAAa,GAGFoI,cAKX,WAAYxI,EAA4CqB,kBAAAA,IAAAA,EAA6B,KACnFqC,cAAM1D,EAAYqB,kBAmBV,WACRqC,EAAK1D,WAAWgC,WAAa2C,SAAS2D,OACtC3D,SAASY,iBAAiB,mBAAoB7B,EAAK+E,yBAGrD/E,YAAY,WACViB,SAASa,oBAAoB,mBAAoB9B,EAAK+E,yBAIhD/E,mBAAmB,SAACjD,GAC1B,IAAMyB,EAAYhC,EAAiB,YAAawD,EAAK1D,WAAY0D,EAAKtD,aAEtEsD,EAAK1D,WAAWgC,WAAY,EAC5BjC,EAAO2D,EAAK1D,WAAY,aAAaiC,KAAKyB,EAAK1D,YAC/C0D,EAAKwC,IAAI,YAAa,CAAElE,WAAW,IAEnC0B,EAAKwD,SAAShF,EAAWzB,IAGnBiD,iBAAiB,SAACjD,GACxB,IAAMyB,EAAYhC,EAAiB,UAAWwD,EAAK1D,WAAY0D,EAAKtD,aAEpEsD,EAAK1D,WAAWgC,WAAY,EAC5BjC,EAAO2D,EAAK1D,WAAY,WAAWiC,KAAKyB,EAAK1D,YAC7C0D,EAAKwC,IAAI,UAAW,CAAElE,WAAW,IAEjC0B,EAAKwD,SAAShF,EAAWzB,IAGnBiD,WAAW,SAACxB,EAAmBzB,GACrC,GAAIiD,EAAKvC,cAAe,CACtB,IAAMT,EAAS,CAAEV,WAAY0D,EAAK1D,WAAYgC,UAAW0B,EAAK1D,WAAWgC,WACnE0G,EAAkBnI,EAAc2B,EAAWzB,GAAS,KAAMC,GAChEgD,EAAK1D,WAAWuB,QAAQJ,cAAcuH,GACtChF,EAAKwC,IAAI,mBAAmBhE,UAAAA,GAAcxB,MAItCgD,yBAAyB,SAACjD,GAC5BkE,SAAS2D,OACX5E,EAAKiF,iBAAiBlI,GAEtBiD,EAAKkF,eAAenI,UA7DiBK,OAAOC,OAAO,GAAIG,EAAgBG,GAAjEF,IAAAA,cAAef,IAAAA,mBACvBU,OAAOC,YAAa,CAAEI,cAAAA,EAAef,YAAAA,IAErCsD,EAAK1D,WAAaA,EAOlBc,OAAOC,OAAOf,EAAY,CAAEyB,WALT,WACjBiC,EAAKlB,YACLkB,EAAKlC,0BAMPkC,EAAK+E,yBAEL/E,EAAKnB,YAtBT,iBAAmCsD,GAyEtBgD,EAAgB,SAAC7I,EAA4CqB,YAAAA,IAAAA,EAA6B,IACrG,IAAMM,EAAW,IAAI6G,EAAcxI,EAAYqB,GAC/C,MAAO,CAACM,EAASY,QAASZ,EAASa,YChFxBsG,cAGX,WAAYpG,gBACVC,cAAMD,SACNE,sBAAsB,iBACSiG,OAAoBlG,EAAKtB,SAA/CkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QAPrC,6BANA,sEACuB,IADvB,iBAAoDK,eCKvCkG,cAIX,WAAY/I,EAAuCqB,2BAAAA,IAAAA,EAAwB,KACzEqC,cAAM1D,EAAYqB,kBAOV,WACRqC,EAAKpC,cAAciE,iBAAiB,aAAc7B,EAAKsF,SACvDtF,EAAKpC,cAAciE,iBAAiB,aAAc7B,EAAKuF,UAGzDvF,YAAY,WACVA,EAAKpC,cAAckE,oBAAoB,aAAc9B,EAAKsF,SAC1DtF,EAAKpC,cAAckE,oBAAoB,aAAc9B,EAAKuF,UAGpDvF,UAAU,WAChB3D,EAAO2D,EAAK1D,WAAY,cAAciC,KAAKyB,EAAK1D,YAChD0D,EAAKwC,IAAI,aAAc,CAAEgD,OAAO,KAG1BxF,UAAU,WAChB3D,EAAO2D,EAAK1D,WAAY,cAAciC,KAAKyB,EAAK1D,YAChD0D,EAAKwC,IAAI,aAAc,CAAEgD,OAAO,KAvBhCxF,EAAKpC,wBAAgBD,YAASE,UAAWvB,EAAWuB,QACpDmC,EAAK1D,WAAaA,EAClB0D,EAAKuD,oBACLvD,EAAKnB,sCAuBC0E,kBAAA,sBACAzF,EAAuBsE,KAAK9F,WAAWyB,WAAWC,KAAKoE,KAAK9F,YAOlEc,OAAOC,OAAO+E,KAAK9F,WAAY,CAAEyB,WALd,WACjBkB,EAAKH,YACLhB,WArCwBqE,GA4CjBsD,EAAW,SAACnJ,EAAuCqB,YAAAA,IAAAA,EAAwB,IACtF,IAAMM,EAAW,IAAIoH,EAAS/I,EAAYqB,GAC1C,MAAO,CAACM,EAASY,QAASZ,EAASa,YC/CxB4G,cAGX,WAAY1G,gBACVgB,cAAMhB,SACNE,sBAAsB,iBACSuG,OAAezF,EAAKrC,SAA1CkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QAPrC,gGAJ+CK,eCQlCwG,cAMX,WAAYrJ,EAA0CqB,2BAAAA,IAAAA,EAA2B,KAC/EqC,cAAM1D,EAAYqB,kBAWV,WACT,IACGqC,EAAK/B,SAASY,QAAQmB,EAAKpC,cAAeoC,EAAKrC,SAC/C,MAAOiI,GACP5F,EAAK1D,WAAWsG,YAAYiD,YAAYD,EAAM,gFAAgF,MAIlI5F,YAAY,WACVA,EAAK/B,SAASF,cAGRiC,WAAW,SAAC7B,GAClB9B,EAAO2D,EAAK1D,WAAY,UAAUiC,KAAKyB,EAAK1D,WAAY6B,GACxD6B,EAAKwC,IAAI,SAAU,CAAErE,QAAAA,KAvBrB6B,EAAKpC,wBAAgBD,YAASE,UAAWvB,EAAWuB,QACpDmC,EAAK1D,WAAaA,EAClB0D,EAAKrC,QAAUA,EACfqC,EAAK/B,SAAW,IAAI6H,iBAAiB9F,EAAK+F,UAE1C/F,EAAKuD,oBACLvD,EAAKnB,sCAoBC0E,kBAAA,sBACAzF,EAAuBsE,KAAK9F,WAAWyB,WAAWC,KAAKoE,KAAK9F,YAKlEc,OAAOC,OAAO+E,KAAK9F,WAAY,CAAEyB,WAJd,WACjBkB,EAAKH,YACLhB,WAvC2BqE,GA6CpB6D,EAAc,SAAC1J,EAA0CqB,YAAAA,IAAAA,EAA2B,IAC/F,IAAMM,EAAW,IAAI0H,EAAYrJ,EAAYqB,GAC7C,MAAO,CAACM,EAASY,QAASZ,EAASa,YCnDxBmH,cAGX,WAAYjH,gBACVgB,cAAMhB,SACNE,sBAAsB,iBACS8G,OAAkBhG,EAAKrC,SAA7CkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QAPrC,gGAJkDK,eCKrC+G,cAYX,WAAY5J,EAAgDqB,yBAAAA,IAAAA,EAAiC,KAC3FqC,cAAM1D,EAAYqB,kBAkBV,WACRqC,EAAK/B,SAASY,QACZmB,EAAKpC,cACL,CACEuI,SAAS,EACTC,eAAe,EACfC,WAAW,EACXC,YAAY,EACZC,mBAAmB,EACnBC,gBAAiB,CAACxG,EAAKyG,eAAgBzG,EAAK0G,yBAKlD1G,YAAY,WACVA,EAAK/B,SAASF,cAGhBiC,WAAW,SAAC7B,GACV,2BAAW4H,UACT,OAAQA,EAASjJ,MACf,IAAK,aACH,IAAI6J,EAAYZ,EAASlF,OAAmBmD,aAAa+B,EAASa,eAIlE,GAAIb,EAASa,gBAAkB5G,EAAKyG,gBAAkBV,EAASa,gBAAkB5G,EAAK0G,qBAAsB,CAE1G,IAAIG,EAAa7G,EAAK8G,4BALTf,EAASgB,UAMlBC,EAAahH,EAAK8G,4BAA4BH,GAC9CM,EAAiBJ,EAAWK,OAAO,SAAArG,UAAWmG,EAAWG,SAAStG,KAClEuG,EAAeJ,EAAWE,OAAO,SAAArG,UAAWgG,EAAWM,SAAStG,KAEpEoG,EAAerF,QAAQ,SAAAf,YAAewG,cAAcrH,EAAKsH,sBAAsBzG,GAASkF,EAASlF,OAAQ,qBACzGuG,EAAaxF,QAAQ,SAAAf,YAAe0G,YAAYvH,EAAKsH,sBAAsBzG,GAASkF,EAASlF,OAAQ,qBAGvG,MACF,IAAK,gBACH,IAAI2G,EAASxH,EAAKyH,qBAAqB1B,EAASlF,QAChD,GAAc,MAAV2G,EACF,iBAEuBxH,EAAK0H,oCAAoCF,GAC/C5F,QAAQ,SAACf,GACxBb,EAAK2H,cAAc3H,EAAKsH,sBAAsBzG,GAAS2G,EAAS,iBAGpE,MACF,IAAK,gBACeI,EAAiB7B,EAAjB6B,aAAiB7B,EAA7B8B,WACKjG,QAAQ,SAACkG,YAAoBC,uBAAuBD,EAAM9H,EAAKuH,eAC1EK,EAAahG,QAAQ,SAACkG,YAAoBC,uBAAuBD,EAAM9H,EAAKqH,wsBAjC3DlJ,kBAAS,8CAnChC6B,EAAK1D,WAAaA,EAClB0D,EAAKrC,QAAUA,EACfqC,EAAKpC,cAAgBtB,EAAWuB,QAChCmC,EAAKpD,WAAaN,EAAW0L,MAAMpL,WACnCoD,EAAKiI,iBAAsBjI,EAAKpD,eAChCoD,EAAKyG,eAAiBnK,EAAW0L,MAAME,OAAOC,gBAC9CnI,EAAK0G,6BAA+B1G,EAAKpD,qBAEzCoD,EAAKoI,QAAUzK,EAAQyK,SAAW9L,EAAW+L,YAAYD,QACzDpI,EAAKsI,gBAAkBtI,EAAKoI,QAAQG,IAAI,SAAC1H,YAAcb,EAAKiI,iBAAmBpH,IAC/Eb,EAAK/B,SAAW,IAAI6H,iBAAiB9F,EAAK+F,UAE1C/F,EAAKuD,oBACLvD,EAAKnB,mBA5BT,2BAyFUkJ,uBAAA,SAAuBD,EAAYU,cACrChB,EAAsBM,EACtBW,EAASD,EACTE,EAA6B,GACV,SAAnBlB,EAAOmB,UAAkF,GAA3DvG,KAAKsF,oCAAoCF,GAAQoB,QACjFH,EAASrG,KAAKuF,cACdH,EAASpF,KAAKqF,qBAAqBK,IAEnCY,EAAmBtG,KAAKsF,oCAAoCF,GAEhD,MAAVA,IAEkC,GAA3BkB,EAAiBE,SAC1BF,EAAmBtG,KAAKsF,oCAAoCF,IAG9DkB,EAAiB9G,QAAQ,SAACf,GACxB4H,EAAOlK,KAAKU,EAAMA,EAAKqI,sBAAsBzG,GAAS2G,EAAS,qBAI3DC,qBAAA,SAAqBK,GAC3B,IAAIN,EAASM,EACTY,EAA6B,GAOjC,IANuB,SAAnBlB,EAAOmB,WACTD,EAAmBtG,KAAKsF,oCAAoCF,IAKjC,OAAtBA,EAAOqB,YAAuBrB,EAAOqB,YAAczG,KAAKxE,eAA4C,GAA3B8K,EAAiBE,QAE/F,GAAwB,WADxBpB,EAASA,EAAOqB,YACLF,UACcvG,KAAKsF,oCAAoCF,GAC3CoB,OAAS,EAE5B,OAAOpB,EAKb,MAAuB,SAAnBA,EAAOmB,UAGc,MAArBnB,EAAOqB,gBAGPrB,EAAOqB,YAAczG,KAAKxE,eAExBwE,KAAKsF,oCAAoCF,GAAQoB,OAAS,EACrDpB,UAOLD,YAAA,SAAY9K,EAAcqL,EAAYgB,GAC5C,IAAIC,EAAoBtM,gBACxB2F,KAAK9F,WAAWyM,IAAmB1M,EAAO+F,KAAK9F,WAAYyM,GAAgBxK,KAAK6D,KAAK9F,WAAYwL,GACjG1F,KAAKI,IAAI,cAAe,CAAE3B,OAAQpE,EAAMqL,KAAAA,EAAMgB,QAAAA,OAGxCzB,cAAA,SAAc5K,EAAcqL,EAAYgB,GAC9C,IAAIC,EAAoBtM,kBACxB2F,KAAK9F,WAAWyM,IAAmB1M,EAAO+F,KAAK9F,WAAYyM,GAAgBxK,KAAK6D,KAAK9F,WAAYwL,GACjG1F,KAAKI,IAAI,gBAAiB,CAAE3B,OAAQpE,EAAMqL,KAAAA,EAAMgB,QAAAA,OAG1CnB,cAAA,SAAclL,EAAcqL,EAAYgB,GAC9C,IAAIC,EAAoBtM,kBACxB2F,KAAK9F,WAAWyM,IAAmB1M,EAAO+F,KAAK9F,WAAYyM,GAAgBxK,KAAK6D,KAAK9F,WAAYwL,GACjG1F,KAAKI,IAAI,gBAAiB,CAAE3B,OAAQpE,EAAMqL,KAAAA,EAAMgB,QAAAA,OAG1CpB,oCAAA,SAAoCI,GAC1C,GAAqB,SAAjBA,EAAKa,SAEP,MAAO,GAGT,IAAIK,EAAclB,EAClB,YAAYhB,4BAA4BkC,EAAYhF,aAAa5B,KAAKsE,uBAAyBsC,EAAYhF,aAAa5B,KAAKqE,oBAGvHK,4BAAA,SAA4BmC,GAGlC,IAAIC,EAAiB9G,KAAKkF,sBAD1B2B,EAAYA,GAAa,IACkCE,MAAM,KACjE,YAAYf,QAAQlB,OAAO,SAACkC,UAAqC,IAA/BF,EAAeG,QAAQD,QAGnD9B,sBAAA,SAAsBzG,GAC5B,OAAOA,EAAOyI,QAAQ,IAAIC,OAAOnH,KAAK6F,iBAAkB,KAAM,OAGxD1E,kBAAA,sBACAzF,EAAuBsE,KAAK9F,WAAWyB,WAAWC,KAAKoE,KAAK9F,YAKlEc,OAAOC,OAAO+E,KAAK9F,WAAY,CAAEyB,WAJd,WACjByL,EAAK1K,YACLhB,WA7LiCqE,GAmM1BsH,EAAoB,SAACnN,EAAgDqB,YAAAA,IAAAA,EAAiC,IACjH,IAAMM,EAAW,IAAIiI,EAAkB5J,EAAYqB,GACnD,MAAO,CAACM,EAASY,QAASZ,EAASa,YCtMxB4K,cAIX,WAAY1K,gBACVgB,cAAMhB,SACNE,sBAAsB,iBACSuK,OAAwBzJ,EAAKrC,SAAnDkB,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QARrC,gGAJwDK,eCM3CwK,EAAkB,SAACrN,GAE9B,IAAMsN,EAAW,SAAC7M,SACoBgE,OAE9B8I,EAA+B,CACnCtI,SAHkBP,aAGK8I,SACvBrI,QAJML,YAIe0I,SACrB/M,MAAAA,GAGFV,EAAOC,EAAY,gBAAgBiC,KAAKjC,EAAYuN,IAGhD/L,EAAuBxB,EAAWyB,WAAWC,KAAK1B,GAElDuC,EAAU,WACdkC,OAAOc,iBAAiB,SAAU+H,GAClCA,KAGI9K,EAAY,WAChBiC,OAAOe,oBAAoB,SAAU8H,IAYvC,OATAxM,OAAOC,OAAOf,EAAY,CACxByB,sBACEe,IACAhB,OAIJe,IAEO,CAACA,EAASC,ICpCNiL,cAEX,WAAY/K,gBACVgB,cAAMhB,SACNE,sBAAsB,iBACSyK,QAAtB9K,OAASC,OAChB1B,OAAOC,YAAa,CAAEwB,QAAAA,EAASC,UAAAA,QANrC,gGAJsDK,eCUhD6K,EAAW,SAACC,EAAcC,YAAAA,IAAAA,EAFZ,KAGlB,IAAIC,EAAkD,KAEtD,kBACE,IAAM7H,EAAO8H,UACPpL,EAAUoD,KAEVwH,EAAW,kBAAMK,EAAGI,MAAMrL,EAASsD,IACrC6H,GACFzF,aAAayF,GAEfA,EAAY5F,WAAWqF,EAAUM,cCXrBI,EAASC,EAAgBL,GACvC,IAAIM,EAEJ,gBAHuCN,IAAAA,EAFrB,gBAMhB,IAAM5H,EAAO8H,UACPpL,EAAUoD,KAEXoI,IACHA,GAAa,EACbD,EAAKF,MAAMrL,EAASsD,GACpBiC,WAAW,kBAAOiG,GAAa,GAAQN,KCP7C,SAASrG,EAAUpH,GACjB,IAAMoB,EAAUoD,SAAS6C,KAAKC,4BAA4BtH,QAC1D,OAAOoB,GAAWA,EAAQmG,aAAa,WAGzC,SAASyG,EAASC,GAChB,IACE,OAAOC,KAAKC,MAAMF,GAClB,MAAOG,GACP,OAAOH,GAIX,SAASI,EAASJ,GAChB,OAAOA,EAAMpB,QAAQ,sBAAuB,SAACyB,EAAGC,UAASA,EAAKC,gBAGnDC,ICjBPC,EAAsB,CAC1BC,WAAY,QACZC,iBAAkB,aAClBC,aAAc,WACdC,WAAY,QACZC,iBAAkB,aAClBC,aAAc,YAGVjO,EAAiB,CACrBC,eAAe,EACff,aAAa,EACbgP,cAAc,EACdC,YAAa,UAGFC,EAAgB,SAACtP,EAA4CqB,eAgEzDkO,WAAWhO,EAAkBiO,EAAwBC,EAAuBC,wBACzFnO,EAAQoO,WAAUC,YAAOJ,MACzBjO,EAAQoO,WAAUC,YAAOH,kCAsD3B,uBAAO,IAAII,QAAQ,SAAAC,GACjBlN,sBAAsB,WACpBA,sBAAsBkN,2CAvDlBC,qCAENxO,EAAQoO,WAAUK,eAAUP,MAC5BlO,EAAQoO,WAAUC,YAAOF,4BAkCEnO,OAC7B,uBAAO,IAAIsO,QAAQ,SAAAC,GACjB,IAAMG,EAKF,IALaC,OACfC,iBAAiB5O,GACd6O,mBACAvD,MAAM,KAAK,GACXG,QAAQ,IAAK,KAGlB/E,WAAW,WACT6H,EAAQG,IACPA,yCA3CGI,CAAgB9O,6BAEtBA,EAAQoO,WAAUK,eAAUR,2CApCfc,WAAM7P,OACnB,IAAKT,EAAWoP,aAAc,yBAC9BpP,EAAWoP,cAAe,EAC1BmB,GAAmBA,EAAgB9P,GAEnC,IAAMwO,EAAavH,EAAa,QAASrG,EAASqF,GAC5CwI,EAAmBxH,EAAa,cAAerG,EAASqF,GACxDyI,EAAezH,EAAa,UAAWrG,EAASqF,0BAEhD6I,EAAWjO,EAAe2N,EAAYC,EAAkBC,oBAExDE,GACJ/N,EAAcqO,UAAUC,IAAIP,yCA9BjBmB,WAAM/P,OACnB,GAAIT,EAAWoP,aAAc,yBAE7BpP,EAAWoP,cAAe,EAC1BqB,GAAmBA,EAAgBhQ,GAEnC,IAAMqO,EAAapH,EAAa,QAASrG,EAASqF,GAC5CqI,EAAmBrH,EAAa,cAAerG,EAASqF,GACxDsI,EAAetH,EAAa,UAAWrG,EAASqF,UAEhD2I,GACJ/N,EAAcqO,UAAUK,OAAOX,mBAG3BE,EAAWjO,EAAewN,EAAYC,EAAkBC,oEAlCQ3N,IAAAA,EAA6B,IACrG,IACIqP,EADEC,EAAc3Q,EAAWuB,QAAwBmF,QAAQkK,iBAG3DD,IACFD,EAAuB1Q,EAAsB2Q,aAG/C,IAAMrP,YAAgBD,YAASE,UAAWmP,GAAuB1Q,EAAWuB,QAG5E,GAAOD,aAAyBuP,aAAiBvP,aAAyBwP,WAA1E,CACA,IAAMpK,EAAUpF,EAAcoF,UAEQ5F,OAAOC,OAAOG,EAAgBG,GAA5D+N,IAAAA,aAAcC,IAAAA,YAEhBoB,WAAkBzQ,EAAWwQ,cAAXO,EAAkBrP,KAAK1B,GACzCuQ,WAAkBvQ,EAAWsQ,cAAXU,EAAkBtP,KAAK1B,GACzCiR,WAA6BjR,EAAWkR,yBAAXC,EAA6BzP,KAAK1B,GA4ErE,OAhBEA,EAAWoP,aAAeA,EACtBA,GACIC,GACJ/N,EAAcqO,UAAUK,OAAOX,GAEjCmB,MAEMnB,GACJ/N,EAAcqO,UAAUC,IAAIP,GAE9BiB,KAKJxP,OAAOC,OAAOf,EAAY,CAAEwQ,MAAAA,EAAOF,MAAAA,EAAOY,iBAAAA,IACnC,CAACV,EAAOF,EAAOY,GAxCtB,SAASA,EAAiBzQ,GACxBwQ,GAA8BA,EAA2BxQ,GAErDT,EAAWoP,aACbkB,IAEAE,MAqCN,SAAS9I,EAAavH,EAAckB,EAA4BqF,GAC9D,IAAM0K,eAA2BjR,EAAK,GAAGwO,cAAgBxO,EAAKkR,OAAO,GAGrE,OADiBhQ,EAAgBlB,IAASuG,EAAQ0K,IAAgB1K,EADvCmI,EAAoB1O,KACiD,IACjF0M,MAAM,SC1HVyE,cAGX,WAAY5O,gBACVC,cAAMD,SACNE,sBAAsB,WACpB0M,OAAoB3M,EAAKtB,aAN/B,6BARA,yEAC0B,IAD1B,iBAAoDwB,6aJyBzB,SAAC7C,EAAgCqB,kBACtCrB,EAAW+L,YAEnBwF,cAAWjM,QAAQ,SAAC2I,GAK9B,GAJoB,iBAATA,IACRjO,EAAmBiO,GAAQP,EAAU1N,EAAmBiO,SAAmB5M,SAAAA,EAASuM,OAGnE,iBAATK,EAAmB,KACpB9N,EAAe8N,EAAf9N,KACR,IAAKA,EAAM,OACVH,EAAmBG,GAAQuN,EAAU1N,EAAmBG,GAFlC8N,EAATL,aAEsEvM,SAAAA,EAASuM,kGKhC5E,SAAC5N,kBACrBA,EAAW+L,YAAoByF,UAAOlM,QAAQ,SAACmM,IANlC,SAACzR,EAAwBG,EAAciO,GACrDtN,OAAOuG,eAAerH,EAAYG,EAAM,CAAEiO,MAAAA,IAMxCsD,CAAQ1R,EAAYyR,EAASzR,EAAmByR,iBHwB7B,SAACzR,EAAwBqB,YAAAA,IAAAA,EAAuB,CAAEsQ,QAAQ,IAC/E,IAAMC,EAAa5R,EAAW+L,YAAoB6F,UAC5CD,EAAStQ,EAAQsQ,aAGvBC,GAAAA,EAAWtM,QAAQ,SAACuM,IAhCG,SAAC7R,EAAwB6R,EAAkBF,GAClE,IAAMG,EAAaH,EAAYnD,EAASqD,UAAkBrD,EAASqD,GAEnE/Q,OAAOuG,eAAerH,EAAY8R,EAAY,CAC5C5O,eACE,OAAOiL,EAAS5G,EAAUsK,OA4B5BE,CAAiB/R,EAAY6R,EAAUF,KAIzC7Q,OAAOuG,eAAerH,EAAY,QAAS,CACzCkD,eACE,IAAM8O,EAA8B,GAQpC,aANAJ,GAAAA,EAAWtM,QAAQ,SAACuM,GAClB,IAAMzD,EAAQD,EAAS5G,EAAUsK,IAC7BzD,MAAAA,IACF4D,EAAOxD,EAASqD,IAAazD,KAG1B4D,wEDzBc,SAAChS,EAAgCqB,kBAAAA,IAAAA,EAA2B,aACjErB,EAAW+L,YAEnBkG,cAAW3M,QAAQ,SAAC2I,SAK9B,GAJoB,iBAATA,IACRjO,EAAmBiO,GAAQD,EAAUhO,EAAmBiO,YAAmB5M,UAAAgF,EAASuH,OAGnE,iBAATK,EAAmB,OACpB9N,EAAe8N,EAAf9N,KACR,IAAKA,EAAM,OACVH,EAAmBG,GAAQ6N,EAAUhO,EAAmBG,GAFlC8N,EAATL,gBAEsEvM,UAAAmF,EAASoH"}
const alpineNames = {
    enterClass: "enter",
    enterActiveClass: "enterStart",
    enterToClass: "enterEnd",
    leaveClass: "leave",
    leaveActiveClass: "leaveStart",
    leaveToClass: "leaveEnd",
};
const defaultOptions = {
    dispatchEvent: true,
    eventPrefix: true,
    transitioned: false,
    hiddenClass: "hidden"
};
export const useTransition = (controller, options = {}) => {
    var _a, _b, _c;
    const targetName = controller.element.dataset.transitionTarget;
    let targetFromAttribute;
    if (targetName) {
        targetFromAttribute = controller[`${targetName}Target`];
    }
    const targetElement = (options === null || options === void 0 ? void 0 : options.element) || targetFromAttribute || controller.element;
    // data attributes are only available on HTMLElement and SVGElement
    if (!((targetElement instanceof HTMLElement) || (targetElement instanceof SVGElement)))
        return;
    const dataset = targetElement.dataset;
    const { transitioned, hiddenClass } = Object.assign(defaultOptions, options);
    const controllerEnter = (_a = controller.enter) === null || _a === void 0 ? void 0 : _a.bind(controller);
    const controllerLeave = (_b = controller.leave) === null || _b === void 0 ? void 0 : _b.bind(controller);
    const controllerToggleTransition = (_c = controller.toggleTransition) === null || _c === void 0 ? void 0 : _c.bind(controller);
    async function enter(event) {
        if (controller.transitioned)
            return;
        controller.transitioned = true;
        controllerEnter && controllerEnter(event);
        const enterClass = getAttribute("enter", options, dataset);
        const enterActiveClass = getAttribute("enterActive", options, dataset);
        const enterToClass = getAttribute("enterTo", options, dataset);
        if (!!hiddenClass) {
            targetElement.classList.remove(hiddenClass);
        }
        await transition(targetElement, enterClass, enterActiveClass, enterToClass);
    }
    async function leave(event) {
        if (!controller.transitioned)
            return;
        controller.transitioned = false;
        controllerLeave && controllerLeave(event);
        const leaveClass = getAttribute("leave", options, dataset);
        const leaveActiveClass = getAttribute("leaveActive", options, dataset);
        const leaveToClass = getAttribute("leaveTo", options, dataset);
        await transition(targetElement, leaveClass, leaveActiveClass, leaveToClass);
        if (!!hiddenClass) {
            targetElement.classList.add(hiddenClass);
        }
    }
    function toggleTransition(event) {
        controllerToggleTransition && controllerToggleTransition(event);
        if (controller.transitioned) {
            leave();
        }
        else {
            enter();
        }
    }
    async function transition(element, initialClass, activeClass, toClass) {
        element.classList.add(...initialClass);
        element.classList.add(...activeClass);
        await nextFrame();
        element.classList.remove(...activeClass);
        element.classList.add(...toClass);
        await afterTransition(element);
        element.classList.remove(...initialClass);
    }
    function initialState() {
        controller.transitioned = transitioned;
        if (transitioned) {
            if (!!hiddenClass) {
                targetElement.classList.remove(hiddenClass);
            }
            enter();
        }
        else {
            if (!!hiddenClass) {
                targetElement.classList.add(hiddenClass);
            }
            leave();
        }
    }
    initialState();
    Object.assign(controller, { enter, leave, toggleTransition });
    return [enter, leave, toggleTransition];
};
function getAttribute(name, options, dataset) {
    const datasetName = `transition${name[0].toUpperCase()}${name.substr(1)}`;
    const datasetAlpineName = alpineNames[name];
    const classes = options[name] || dataset[datasetName] || dataset[datasetAlpineName] || "";
    return classes.split(" ");
}
async function afterTransition(element) {
    return new Promise(resolve => {
        const duration = Number(getComputedStyle(element)
            .transitionDuration
            .split(",")[0]
            .replace('s', '')) * 1000;
        setTimeout(() => {
            resolve(duration);
        }, duration);
    });
}
async function nextFrame() {
    return new Promise(resolve => {
        requestAnimationFrame(() => {
            requestAnimationFrame(resolve);
        });
    });
}
//# sourceMappingURL=use-transition.js.map